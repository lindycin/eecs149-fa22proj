/**
 * Template for robot driving lab exercises.
 * This template just periodically switches between a
 * STOPPED and a DRIVING mode, updating the LCD display
 * on each change of mode.
 */
target C {
    threading: false,
    build: "../scripts/build_nrf_unix.sh"   
};

import Display from "lib/Display.lf";
import EncoderToDistance from "lib/EncoderToDistance_Template.lf";
import GyroAngle from "lib/GyroAngle.lf";
import ArrowKeys from "BLE_Template.lf"

preamble {=
    // Include the functions for driving the robot
    // and reading its sensors.
    #include "lib/romi.h"

    //TODO: gyro axis, turn angle
    // turn speed, turn direction
=}

reactor Robot {
    input drive:bool;       // Toggle mode.
    input encoder_val:uint32_t;
    input obstacle_detected:bool;

    output notify:string;   // Notify of mode change.
    output distance:string;
    output set_drive:bool;

    input upKey:bool;
    input downKey:bool;
    input leftKey:bool;
    input rightKey:bool;

    reaction(startup) -> notify {=
        // Initialize the robot.
        APP_ERROR_CHECK(romi_init());
        lf_set(notify, "INIT");
    =}

    initial mode STOPPED {
        reaction(drive) -> reset(DRIVING), notify {=
            if (drive->value)
            {
                
                romi_drive_direct(75, 75);
                lf_set(notify, "DRIVING!!!");
                lf_set_mode(DRIVING);
            }
        =}
    }

    mode DRIVING {
        encoderToDist = new EncoderToDistance();

        encoderToDist.distanceStr -> distance;

        reaction(encoder_val) -> encoderToDist.encoder {=
            lf_set(encoderToDist.encoder, encoder_val->value);
        =}

        reaction(drive) -> STOPPED, notify, set_drive {=
            if (!(drive->value))
            {
                romi_drive_direct(0, 0);
                
                lf_set(set_drive, 0);
                lf_set(notify, "STOPPED");
                lf_set_mode(STOPPED);
            }
        =}

        reaction(encoderToDist.distance) -> set_drive, reset(STOPPED), reset(TURNING), notify{=
            // Drive only 0.5 meter

            // if (encoderToDist.distance->value >= .5)
            // {   // 7-2-3-5 checkoff
            //     // lf_set_mode(STOPPED);
            //     // lf_set(set_drive, 0);
            //     // romi_drive_direct(0, 0);
            //     // lf_set(notify, "STOPPED");
                
            //     romi_drive_direct(75, -75);
            //     lf_set(notify, "TURNING");
            //     lf_set_mode(TURNING);
            // }
        =}

        reaction(upKey, downKey, leftKey, rightKey) {=
            if(upKey->value) 
                romi_drive_direct(150,150);
            if (downKey->value)
                romi_drive_direct(-150,-150);
            if (leftKey->value)
                romi_drive_direct(-150,150); //left
            if (rightKey->value)
                romi_drive_direct(150,-150);
            if (!(upKey->value || downKey->value || leftKey->value || rightKey->value)) 
                romi_drive_direct(0,0);
        =}

        reaction(obstacle_detected) -> reset(OBSTACLE), notify {=
            if (obstacle_detected->value) {
                
                romi_drive_direct(-75, -75);
                lf_set(notify, "OBSTACLE");
                lf_set_mode(OBSTACLE);
            }
        =}
    }

    mode TURNING {
        gyro = new GyroAngle();

        reaction(drive) -> STOPPED, set_drive, notify {=
            if (!(drive->value))
            {
                romi_drive_direct(0, 0);
                
                lf_set(set_drive, 0);
                lf_set(notify, "STOPPED");
                lf_set_mode(STOPPED);
            }
        =}

        reaction(gyro.z) -> reset(DRIVING), notify {=
            if (gyro.z->value < -90.0)
            {
                romi_drive_direct(75, 75);

                lf_set(notify, "DRIVING!!!");
                lf_set_mode(DRIVING);
            }
        =}
    }

    // 7-2-6-2 checkoff
    mode OBSTACLE {
        gyro2 = new GyroAngle();
        encoderToDist2 = new EncoderToDistance();

        encoderToDist2.distanceStr -> distance;

        reaction(encoder_val) -> encoderToDist2.encoder {=
            lf_set(encoderToDist2.encoder, encoder_val->value);
        =}

        reaction(gyro2.z, encoderToDist2.distance) -> reset(DRIVING), notify{=
            // back 0.1 meter and turn and back to driving state

            if (encoderToDist2.distance->value <= -.1)
            {  
                romi_drive_direct(75, -75);
            }

            if (gyro2.z->value < -45.0)
            {
                lf_set_mode(DRIVING);
                romi_drive_direct(75, 75);
                lf_set(notify, "DRIVING!!!");
            }
        =}

        reaction(drive) -> STOPPED, notify, set_drive {=
            if (!(drive->value))
            {
                lf_set_mode(STOPPED);
                lf_set(set_drive, 0);
                romi_drive_direct(0, 0);
                lf_set(notify, "STOPPED");
            }
        =}
    }
}

main reactor {
    timer t(0, 100 msec);
    state drive:bool(true);
    robot = new Robot();
    display = new Display(row = 0);
    display2 = new Display(row = 1);
    arrowKeys = new ArrowKeys();

    arrowKeys.up, arrowKeys.down, arrowKeys.left, arrowKeys.right -> robot.upKey, robot.downKey, robot.leftKey, robot.rightKey;

    reaction(t) -> robot.drive, robot.encoder_val, robot.obstacle_detected{=
        // Toggle the drive state variable for next time.

        static romi_sensors_t sensor;
        romi_sensors_poll(&sensor);

        lf_set(robot.encoder_val, sensor.encoders.left);

        if (romi_button_pressed(&sensor))
        {
            self->drive = !self->drive;
            lf_set(robot.drive, self->drive);
        }

        // 7-2-5-2    // robot.notify -> display.message;
    // robot.distance -> display2.message; checkoff
        if(sensor.bumps.left || sensor.bumps.right || sensor.bumps.center) 
        {
            // self->drive = 0;
            // lf_set(robot.drive, self->drive);

            // 7-2-6-2 checkoff
            lf_set(robot.obstacle_detected, 1);
        }
    =}

    reaction(robot.set_drive) {=
        self->drive = robot.set_drive->value;
    =}

    robot.notify -> display2.message;
    // robot.distance -> display2.message;
    //robot.
}
